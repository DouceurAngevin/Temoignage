<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Carrousel — infini, 2 pleines + peeks avec fondu</title>
<style>
  :root{
    --bg:#191919; --surface:#2f3437; --card:#2a2f32; --text:#f7f6f3; --muted:#9b9a97; --accent:#f1f1ef;

    --gap:14px;
    --peek:32px;                           /* débord symétrique g/d (peeks) */
    --fade: calc(var(--peek) * 0.9);       /* largeur du fondu latéral */
    --peek-extra: 24px;                    /* ⬅ crée de la place pour la tuile coupée droite & gauche */
    --radius:12px;
    --shadow:0 18px 40px rgba(15,15,15,.55);
    --transition:600ms cubic-bezier(.22,.61,.36,1);

    /* 2 cartes pleines visibles (un poil plus étroites pour laisser de la place aux peeks) */
    --card-width: calc((100% - var(--gap) - var(--peek-extra)) / 2);

    color-scheme:dark;
  }

  *{ box-sizing:border-box; }

  body{
    margin:0;
    background:var(--bg);
    color:var(--text);
    font:16px/1.6 "Inter","Segoe UI",-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;
    padding: clamp(20px,4vh,36px) clamp(16px,4vw,28px);
    overflow-x:hidden;
  }

  .wrap{ width:100%; margin:0 auto; }
  .carousel{ position:relative; isolation:isolate; }

  /* Peeks symétriques via padding L/R identique + fondu */
  .viewport{
    overflow:hidden;
    padding:6px var(--peek);
    position:relative;
    z-index:0; /* sous les flèches */
    touch-action:pan-y;

    /* Fondu latéral (mask natif) */
    -webkit-mask-image: linear-gradient(to right,
      transparent 0,
      #000 var(--fade),
      #000 calc(100% - var(--fade)),
      transparent 100%);
    mask-image: linear-gradient(to right,
      transparent 0,
      #000 var(--fade),
      #000 calc(100% - var(--fade)),
      transparent 100%);
    -webkit-mask-size: 100% 100%;
    mask-size: 100% 100%;
    -webkit-mask-repeat: no-repeat;
    mask-repeat: no-repeat;
  }
  /* Fallback overlay (ne bloque pas les clics) */
  .viewport::before,
  .viewport::after{
    content:"";
    position:absolute;
    top:0; bottom:0;
    width: var(--fade);
    pointer-events:none;
    z-index:5; /* sous les flèches (voir .nav) */
  }
  .viewport::before{
    left:0;
    background: linear-gradient(to right, var(--bg) 0%, rgba(25,25,25,0) 100%);
  }
  .viewport::after{
    right:0;
    background: linear-gradient(to left, var(--bg) 0%, rgba(25,25,25,0) 100%);
  }

  .track{
    display:flex; align-items:stretch; gap:var(--gap);
    will-change:transform;
    transition: transform var(--transition);
    padding:8px 0;
  }

  .card{
    flex:0 0 var(--card-width);
    background:var(--card);
    border:1px solid rgba(255,255,255,.06);
    border-radius:var(--radius);
    box-shadow:var(--shadow);
    padding:18px 18px 16px;
    display:grid; gap:12px; min-height:150px;
  }

  .quote{ font-size:16px; font-weight:600; letter-spacing:.01em; line-height:1.55; }
  .meta{ color:var(--muted); font-size:13px; line-height:1.5; white-space:pre-line; }

  /* Flèches (au-dessus de tout, cliquables) */
  .nav{
    position:absolute; top:50%; transform:translateY(-50%);
    width:34px; height:34px; display:grid; place-items:center;
    border-radius:999px; border:1px solid rgba(255,255,255,.08);
    background:var(--surface); box-shadow:inset 0 0 0 1px rgba(255,255,255,.03);
    backdrop-filter:blur(8px);
    cursor:pointer; user-select:none;
    transition: background .2s ease, opacity .2s ease;
    opacity:.95;
    z-index:9999; pointer-events:auto;
  }
  .nav:hover{ background:rgba(63,69,72,.85); opacity:1; }
  .prev{ left:8px; }
  .next{ right:8px; }
  .nav svg{ width:14px; height:14px; color:var(--accent); }

  /* Mobile : 1 carte (peeks non garantis si très étroit) */
  @media (max-width:600px){
    :root{ --peek:18px; --gap:12px; --card-width:100%; --fade:14px; --peek-extra: 0px; }
    body{ padding: clamp(18px,5vh,24px) 18px clamp(18px,5vh,24px); }
    .card{ min-height:0; padding:16px; }
  }
  @media (max-width:420px){ :root{ --peek:14px; --fade:12px; } }
  @media (max-width:360px){ :root{ --peek:12px; --fade:10px; } .quote{ font-size:15px; } }
</style>
</head>
<body>
  <div class="wrap">
    <div class="carousel" aria-label="Carrousel de témoignages">
      <button class="nav prev" aria-label="Témoignages précédents">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
             stroke-linecap="round" stroke-linejoin="round"><polyline points="15 18 9 12 15 6"/></svg>
      </button>

      <div class="viewport">
        <div class="track" role="list">
          <article class="card" role="listitem">
            <div class="quote">“On a doublé notre taux de conversion en 8 semaines, sans augmenter le trafic.”</div>
            <div class="meta">— Responsable e-commerce, Maison Pinet
→ La mission : audit + réécriture des pages produit</div>
          </article>
          <article class="card" role="listitem">
            <div class="quote">“Clair, net, efficace. Les emails de relance ont relancé… notre croissance.”</div>
            <div class="meta">— Head of Sales, TechNova
→ La mission : séquence d’emails + scripts d’appels</div>
          </article>
          <article class="card" role="listitem">
            <div class="quote">“Enfin un messaging qui parle à nos clients industriels — et qui vend.”</div>
            <div class="meta">— Directeur Commercial, FerraSteel
→ La mission : positionnement + pages solutions</div>
          </article>
          <article class="card" role="listitem">
            <div class="quote">“Le configurateur est devenu notre meilleur commercial.”</div>
            <div class="meta">— CEO, Hedonia
→ La mission : UX copy du configurateur + offres</div>
          </article>
          <article class="card" role="listitem">
            <div class="quote">“Nos appels sont plus courts et concluent plus. Les scripts font la différence.”</div>
            <div class="meta">— Sales Ops, IndusFlow
→ La mission : scripts d’appel + objection-handling</div>
          </article>
          <article class="card" role="listitem">
            <div class="quote">“Des textes qui sonnent juste et une ligne éditoriale qui fédère.”</div>
            <div class="meta">— CMO, Sur La Route Des Saveurs
→ La mission : charte édito + landing</div>
          </article>
        </div>
      </div>

      <button class="nav next" aria-label="Témoignages suivants">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
             stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"/></svg>
      </button>
    </div>
  </div>

<script>
(function(){
  const viewport = document.querySelector('.viewport');
  const track = document.querySelector('.track');
  const prevBtn = document.querySelector('.prev');
  const nextBtn = document.querySelector('.next');

  const STEP = 1;        // 1 carte par clic
  const AUTOPLAY_MS = 0; // 10000 si tu veux l’autoplay
  const VISIBLE = 2;     // 2 pleines garanties

  let index = 0;
  let slides = [];
  let timer = null;

  // Helpers
  const css  = (el, prop) => parseFloat(getComputedStyle(el)[prop]) || 0;
  const padL = () => css(viewport,'paddingLeft');
  const padR = () => css(viewport,'paddingRight');
  const peek = () => padL(); // symétrique
  const gap  = () => (getComputedStyle(track).columnGap ? css(track,'columnGap') : css(track,'gap'));
  const cardW= () => slides[0]?.getBoundingClientRect().width || 0;
  const innerWidth = () => viewport.getBoundingClientRect().width - padL() - padR();

  // Espace “slack” restant après 2 cartes + gap → on le partage à gauche/droite
  const slack = () => Math.max(0, innerWidth() - (2*cardW() + gap()));
  const centerOffset = () => slack() / 2;

  // Clones (boucle infinie)
  function setupClones(){
    track.querySelectorAll('[data-clone="1"]').forEach(n => n.remove());
    const originals = Array.from(track.children);
    if(originals.length === 0) return;

    const head = originals.slice(0, VISIBLE + 1).map(n => { const c=n.cloneNode(true); c.dataset.clone='1'; return c; });
    const tail = originals.slice(-VISIBLE - 1).map(n => { const c=n.cloneNode(true); c.dataset.clone='1'; return c; });

    tail.forEach(n => track.insertBefore(n, track.firstChild));
    head.forEach(n => track.appendChild(n));

    slides = Array.from(track.children);

    // départ : 1 peek gauche + 2 pleines + 1 peek droite (grâce au centerOffset)
    index = VISIBLE + 1;
    requestAnimationFrame(()=> goTo(index, false));
  }

  function goTo(i, withTransition=true){
    const x = - (i * (cardW() + gap())) + peek() + centerOffset();
    track.style.transition = withTransition ? '' : 'none';
    track.style.transform = `translate3d(${x}px,0,0)`;
    index = i;
  }

  const next = () => goTo(index + STEP, true);
  const prev = () => goTo(index - STEP, true);

  // Rebouclage silencieux (infini)
  track.addEventListener('transitionend', ()=>{
    const total = slides.length;
    if(total === 0) return;
    if(index >= total - (VISIBLE + 1)) goTo(VISIBLE + 1, false);
    if(index <= VISIBLE)               goTo(total - (VISIBLE + 2), false);
  });

  // Drag (swipe)
  let startX=0, dx=0, dragging=false, baseX=0;
  viewport.addEventListener('pointerdown', (e)=>{
    dragging = true;
    startX = e.clientX;
    track.style.transition = 'none';
    const m = track.style.transform.match(/-?\d+\.?\d*/);
    baseX = m ? parseFloat(m[0]) : 0;
    viewport.setPointerCapture?.(e.pointerId);
    stopAutoplay();
  });
  addEventListener('pointermove', (e)=>{
    if(!dragging) return;
    dx = e.clientX - startX;
    track.style.transform = `translate3d(${baseX + dx}px,0,0)`;
  });
  addEventListener('pointerup', (e)=>{
    if(!dragging) return;
    dragging = false;
    const threshold = Math.max(30, cardW()*0.15);
    if(dx < -threshold) next();
    else if(dx > threshold) prev();
    else goTo(index, true);
    dx = 0;
    viewport.releasePointerCapture?.(e.pointerId);
    startAutoplay();
  });

  // Autoplay (optionnel)
  function startAutoplay(){
    if(!AUTOPLAY_MS) return;
    stopAutoplay();
    timer = setInterval(next, AUTOPLAY_MS);
  }
  function stopAutoplay(){ if(timer){ clearInterval(timer); timer=null; } }
  ['mouseenter','focusin'].forEach(evt => viewport.addEventListener(evt, stopAutoplay));
  ['mouseleave','focusout'].forEach(evt => viewport.addEventListener(evt, startAutoplay));

  // Rebuild clones au resize (on garde VISIBLE=2 et le centrage symétrique)
  let resizeRaf=null;
  addEventListener('resize', ()=>{
    if(resizeRaf) cancelAnimationFrame(resizeRaf);
    resizeRaf = requestAnimationFrame(setupClones);
  });

  // Boutons
  document.querySelector('.next').addEventListener('click', next);
  document.querySelector('.prev').addEventListener('click', prev);

  // Init
  setupClones();
  startAutoplay();
})();
</script>
</body>
</html>
